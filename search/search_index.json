{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to NHBSystems","text":"<p>Right now, this site is just to host documentation for the products I currently sell on Tindie. These are circuit boards I've designed to solve problems I've encountered in the world of mechanical testing instrumentation, and civil  infrastructure monitoring. I make and sell these in the hope that they may solve other peoples problems as well. I also hope to share related information that others  may find useful.</p>"},{"location":"6-channel-24-bit-featherwing/","title":"6 Channel, 24-bit FeatherWing","text":""},{"location":"6-channel-24-bit-featherwing/#description","title":"Description","text":"<p>This is a simple but versatile Feather compatible board. It uses an AD7794, a very robust 6 channel 24 bit ADC. It's a relatively slow converter (470 Hz Max \u2013 single channel), but this board is really suited for lower power, monitoring type applications and can consume as little as 2 \u03bcA in standby. It has an on-board 2.5 V regulator for excitation voltage and is designed primarily to read load cells and pressure gauges. However, it can also be used to read any ratiometric sensor (such as potentiometers), thermocouples, or any 0 \u2013 3.3 V signal.</p>"},{"location":"6-channel-24-bit-featherwing/#specs","title":"Specs","text":"<ul> <li>RMS noise down to 40 nV at lowest data rate (4.17 Hz)</li> <li>Power-down current: 1 \u03bcA maximum (AD7794 chip)</li> <li>Low noise, programmable gain, instrumentation amplifier</li> <li>Band gap reference with 4 ppm/\u00b0C drift typical</li> <li>Simultaneous 50 Hz/60 Hz rejection</li> <li>Update rate: 4.17 Hz to 470 Hz</li> <li>Six differential analog inputs</li> <li>4 pin connections with excitation and ground for each channel</li> <li>On board 2.5v LDO with enable pin broken out to turn off excitation for low power applications</li> </ul> <p>This guide assumes you are familiar with the basics of working with the Arduino IDE and using Arduino compatible boards. While this is designed as a \"FeatherWing\" board, it can also be used with other Arduino boards, either in a breadboard, or directly wired.</p>"},{"location":"6-channel-24-bit-featherwing/#pinouts","title":"Pinouts","text":""},{"location":"6-channel-24-bit-featherwing/#featherwing-pins","title":"FeatherWing Pins","text":"Pin Function Pin 2 3.3V Power In Pin 4 Ground Pin 11 SPI SCLK Pin 12 SPI MOSI Pin 13 SPI MISO Pin 21 EX Enable (depends on jumper) Pin 22 SPI CS (default) <p>All other pins are NC (No connection)</p> <ul> <li>The CS Jumper determines if SPI Chip Select is connected to Pin 22. If cut, you must wire the CS wire pad to another pin.</li> <li>The EX Enable jumper sets excitation mode. The default setting is 2.5 volt excitation voltage is always ON. If you cut the jumper trace, the excitation voltage is controlled by the wire pad. If you cut the jumper trace and solder the other jumper position closed, the excitation voltage will be controlled by pin 21.</li> </ul>"},{"location":"6-channel-24-bit-featherwing/#sensor-input-pins","title":"Sensor Input Pins","text":"<p>For each input there is a group of 4 pins that follows the following convention.</p> Pin Function GND Signal ground EX+ 2.5V excitation voltage S- Signal (-) S+ Signal (+) <p>Note that the input group pin order is rotated around the board, not mirrored. This is to accommodate the use of polarized connectors for sensor cables.</p>"},{"location":"6-channel-24-bit-featherwing/#installing-the-library","title":"Installing the Library","text":"<p>An Arduino library for using the AD7798 ADC chip is available through the Arduino library manager. To install open up the library manager and type \"NHB_AD7794\" into the search bar. (You probably won't have to type more than the nhb part)</p> <p></p> <p>If you prefer to install manually you can download or clone the repository from here: https://github.com/NHBSystems/NHB_AD7794 This is also where you can find the API documentation for the library.</p>"},{"location":"6-channel-24-bit-featherwing/#running-the-example-sketch","title":"Running the Example Sketch","text":"<p>From File-&gt;Examples select the Read_6Ch example</p> <p></p> <p>Once opened, you will need to change the pin assignments to suit your board (unless you happen to be using a Feather M0 Basic)</p> <p></p> <p>That is probably all you have to change for the example to run, however there are a couple of other things you may want to change depending on your setup.</p>"},{"location":"6-channel-24-bit-featherwing/#other-modifications","title":"Other Modifications","text":"<p>The example waits for a serial connection before starting. You can comment out the following line if that is not what you want.</p> <pre><code>while(!Serial);\n</code></pre> <p>If your application doesn't use the EX Enable pin, you can probably get rid of these 2 lines.</p> <pre><code>pinMode(EX_EN_PIN, OUTPUT);\ndigitalWrite(EX_EN_PIN,LOW);  //low  = 2.5 Vex ON\n</code></pre> <p>Finally, depending on what you are trying to measure, you may want to edit the following to suit your needs. The default settings are good for reading load cells or strain gauges as fast as possible.</p> <pre><code>adc.setUpdateRate(470);\n\nfor(int i=0; i &lt; 6; i++){\n  adc.setBipolar(i,true);\n  //delay(2);\n  adc.setGain(i, 128);\n  //delay(2);\n  adc.setEnabled(i,true);\n  //delay(2);\n}\n</code></pre> <p>setUpdateRate() Sets the output data rate and filtering for all channels. It is the rate at which a single channel is converted and filtered. This is not the sampling rate you can expect to see if reading multiple channels. The actual output rate (especially if reading all 6 channels) will be significantly slower. The example setting of 470Hz is the fastest rate, but it may result in noisier readings. A setting of 19.6 will enable 90 dB of 60 Hz noise rejection. The following table shows a subset of valid settings. Refer to the data sheet for the full list, however these are the only ones I ever use.</p> Freq (Hz) Settling time (ms) Noise Rejection 470 4 \u2014 19.6 101 90 dB (60 Hz only) 16.7 120 90 dB (50 Hz only) 12.5 200 80 dB (50/60 Hz) 10 300 69 dB (50/60 Hz) 4.17 480 69 dB (50/60 Hz) <p>setGain(ch, gain) Sets the programmable gain amplifier for the specified channel. Valid values are 1, 2, 4, 8, 16, 32, 64, and 128. Higher gain = more sensitive, but smaller measurement range.</p> <p>setBipolar(ch, isBipolar) Sets whether the given channel is converted as a bipolar signal (+/- 1.25V), or a unipolar (0V-2.5V) signal. If you are reading load cells, strain gauges, or thermocouples, you want bipolar. If you are reading a potentiometer or thermistor, you probably want unipolar. NOTE: Bipolar mode does not mean the device can tolerate voltages that are negative with respect to GND!*</p> <p>setEnabled(ch, isEnabled) Sets whether or not (you guessed it) the channel is enabled. If you are using the channel, it should be enabled, pretty straightforward.</p> <p>* Reading thermocouples requires soldering the bottom side jumpers for the desired channel closed to enable the 1M bias resistors. While it is technically possible to read thermocouples on channels 0 through 2 with the right settings, I find that the results are a little noisy.</p>"},{"location":"6-channel-24-bit-featherwing/#additional-info","title":"Additional Info","text":"<p>More details about the library API can be found in the Readme of the GitHub repo located here: https://github.com/NHBSystems/NHB_AD7794</p> <p>There is a second example included with the library named Read_Thermocouple.ino that shows how to read a Type K thermocouple including functions to handle the scaling and linearization. Remember that you need to solder the bias resistor jumpers closed on the channel you are reading the thermocouple on.</p> <p></p>"},{"location":"about/","title":"Dixi populo tum ad","text":""},{"location":"about/#nec-eumenides-corpus-pecudesque","title":"Nec Eumenides corpus pecudesque","text":"<p>Lorem markdownum fuisset nimius arboris adimunt modo, cetera luctisono! Bistoniis saepe dextera Aegaeona si collo gerere, manus Iovis languore recurvas in amplexas Palladis, tamen. Rara forma illo macies, quod metuit umor teneas an primum infans, placeas, hoc mentem planamque en habebat?</p> <ol> <li>Unda fuerat matres pulchra mihi</li> <li>In longius</li> <li>Cyllenius suae</li> </ol>"},{"location":"about/#alii-fugerat-novo-exsiluere","title":"Alii fugerat novo exsiluere","text":"<p>Quo memor sagitta; in Sirenes concipit frustraque et prior tumulumque tene spectes quoque insula misistis vitamque illo. Ut variat tulit venerat Iapygis puerilibus et Phoebi cupidisque <code>trimPretestE</code> hedera notam, sinu utque suum digna, alta. Est dotalem, desunt et et ne armiger habens obliquantem iuvenis limen erit hauserit madent congelat, caecisque tenui inritamen. Sparsae convexum habet, excessisse mihi praecipitique Iove. Cum Itys plebe, moneo tamen erit luxuriem temptabat et deorum, totidemque de.</p> <p>Regis ancipiti nam. Munus ab nocet caput potuit, in silices contraria et culpae non neve.</p>"},{"location":"about/#vimen-naturale-non-mitis","title":"Vimen naturale non mitis","text":"<p>Gratissima nisi; male natus duorum finire loqui, atque; sororum proripit. Natales quam.</p>"},{"location":"about/#removit-caerula-maturo","title":"Removit caerula maturo","text":"<p>Sua quem reperire excedere ut iacet: nudo, Lami cura famae formosior. Tibi ite et inicere petenda. Piget corpus certaminis suo et habuissem, super ipsa permiscuit, quoque. Eripiunt misi; corda, ab pensas silent fertilis, rite intus ut marmore ultima.</p> <p>Circuit altissimus stabula gratamque admisso, et saxea stricto huic: dextra. Ponti <code>bps_vdu</code> nam habebit victa suos Vulcania <code>xmpIpBanner</code> ponit moriturus latusque genuit est.</p>"},{"location":"analog_sensors/","title":"Reading Analog Sensors","text":"<p>By Jaimy | March 28, 2021</p> <p>This is a quick guide on how to connect various analog sensors to the 6 Channel, Full Bridge FeatherWing. I'll try to give a little background on some of the sensor types, but this is not intended to be a detailed explanation of the underlying principles. Hopefully this will be enough to get you going in your potential application.</p>"},{"location":"analog_sensors/#wheatstone-bridge-sensors","title":"Wheatstone Bridge Sensors","text":"<p>A Wheatstone bridge is a classic analog circuit for measuring an unknown resistance or perhaps more importantly, very small changes in resistance. Sensors that utilize Wheatstone bridges are usually referred to simply as \"bridge\" or \"bridge output\" sensors. They are most commonly associated with strain gauge based sensors, though they can also be used for other resistive sensors like RTDs and thermistors. For right now I will just focus on strain gauge circuits.</p> <p> Basic Wheatstone bridge Circuit</p>"},{"location":"analog_sensors/#full-bridge-sensors","title":"Full Bridge Sensors","text":"<p>-Standard (non-amplified) load cells, pressure gauges, etc.-</p> <p>The most common (and easiest to use) type of strain gauged bridge sensor is the full bridge. In this configuration, all 4 of the bridge resistance elements are contained in the sensor. The most common use of full bridge sensors are for load cells and pressure gauges. Generally in these sensors all bridge elements are active, meaning all four vary with external stimulus. However some special applications may have 2 or 3 passive bridge completion resistors and only 1 or 2 elements are active. Fortunately, for this type of sensor, it really doesn't matter how it's configured on the inside, they are all treated the same \u2013 as a full bridge sensor.</p> <p>The output signal of a full bridge sensor is a very small voltage that is fraction of the input, or excitation voltage. The expected output of a bridge sensor is usually stated as it's mV/V output (millivolts per volt of excitation), at the full scale of the sensor. For example, if you have a 100 lb. load cell, and it's stated output is 2.2 mV/V, it will read 2.2 mV for every volt of excitation, when 100 lbs. of force is applied to it. Common output values for bridge sensors range from 1 mV/V to 4 mV/V. These outputs are too small to read accurately with the built in ADCs on most microcontrollers, which is why we typically need something like the AD7794. It has a programable gain amplifier and 24 bits of resolution to accurately read such small voltages.</p> <p>Note: I have seen some cheap \"load cells\" out there that are actually only a quarter bridge or half bridge device. These need to be handled differently and will be discussed later.</p> <p>Wiring up a full bridge sensor to the FeatherWing is actually quite easy (it is the main thing it was designed for). The general configuration is 4 wires. Two wires for the excitation voltage (usually marked as EX+ and EX-) and two wires for the output signal (usually marked as S+ and S-). They can be wired directly into the 4 terminals of any of the six available sensor input channels as shown below. This is the same the same for a load cell, pressure gauge, or any other full bridge sensor. You can safely reverse the polarity of the output signal by swapping the S+ and S- leads.</p> <p> Bridge sensor connection to sensor input channels</p> <p>There is often a shield wire too. Technically, the shield should be connected to a conductive enclosure if you have one. However if you don't have a conductive enclosure around your project, you may find that tying it into the GND connection helps with noise. In some circumstances though, it can actually create more problems (like if the load cell body at the other end is in contact with a different ground potential) so don't always assume that it will be better.</p> <p>We will need set the AD7794 to Bipolar mode. We will also want to set gain to 128, though some higher output sensors, or an very unbalanced bridge (large zero offset) may need it set to 64 to see the full output range.</p> <pre><code>AD7794 adc(AD7794_CS, 4000000, 2.50);\n\nvoid setup() {\n   ...\n   adc.begin();\n   ...\n   int ch = 0;  //Channel bridge sensor is on\n   ad7794.setBipolar(ch, true);\n   ad7794.setGain(ch, 128);\n   ad7794.setEnabled(ch, true);\n   ...\n}\n</code></pre> <p>To read the sensor we first need to read the voltage</p> <pre><code>float rawVolts = ad7794.read(ch);\n</code></pre> <p>And then we need to scale it. We will convert rawVolts to mV/V by multiplying by 1000, and dividing by the excitation voltage. Then we will multiply by the scaling factor that we can get from the mV/V rating of the load cell (or better yet, obtained from a calibration). We can use a simple function like below to handle this.</p> <pre><code>float voltsToEngUnits(float vIn, float vEx, float scaleFactor){\n   float mVpV = (vIn * 1000) / vEx;\n   return mVpV * scaleFactor;\n }\n</code></pre> <p>As an example, I have a small 10 lb. load cell I like to use when trying things out at my desk. It has a nominal rated output of 2 mV/V. In this case my scaling factor would be 5.00 (10 lb. / 2 mV/V = 5.00 ) and If I am using the AD7794 FeatherWing, the provided excitation voltage will be 2.50 V. So I can get my scaled output like this.</p> <pre><code>const float vEx = 2.500;\nconst float factor = 5.000;\n\nfloat loadLbs = voltsToEngUnits(rawVolts, vEx, factor);\nSerial.println(loadLbs);\n</code></pre> <p>Of course you usually wont have such nice round numbers in a real application.</p> <p>If you wanted to be really precise, or use an externally supplied excitation voltage, you could measure the excitation voltage on another channel (using the internal reference voltage) and use the measured voltage in the calculation. This is also how you could implement a 6 wire bridge connection that adds remote sense connections to compensate for voltage drop of the excitation voltage over very long cable runs. These are special cases and are beyond the scope of this guide, at least for right now.</p>"},{"location":"analog_sensors/#quarter-bridge-sensors","title":"Quarter Bridge Sensors","text":"<p>A quarter bridge (or 1/4 bridge) sensor consists of only a single resistive sensing element. The rest of the Wheatstone bridge circuit needs to be completed by bridge completion resistors. The most common 1/4 bridge sensor by far is a single strain gauge, so that is what we'll focus on here.</p> <p> A strain gauge installed on a steel beam</p> <p>Strain gauges come in 3 common resistances; 120 Ohm, 350 Ohm, and 1000 Ohm. I recommend the 1000 Ohm variety for 2 reasons. First, they draw less current. This is obviously good if your trying you're running off a battery, but also because strain gages can drift due to self heating. Less current means less self heating, and therefore less drift. The second reason is that 1000 Ohms is a common resistance. Bridge completion resistors need have extremely tight tolerances and (perhaps more importantly), they need to have extremely small temperature coeffects. It can be much easier to find an acceptable 1000 Ohm resistor than a 120 or 350. The latter can be hard to find, and you could end up paying quite a bit for a single resistor.</p> <p>Electrically speaking, the circuit is basically the same as the full bridge. In this case however, only one of the 4 resistances is a sensing element, and it is typically located at the end of some length of wire and bonded to the item you are testing. R1 through R3 are simply precision resistors.</p> <p> Quarter bridge circuit</p> <p>Another subtle difference is that the S+ connection should be connected at the strain gauge, not at the bridge completion resistor. This is to reduce the effects of the strain gauge lead wire resistance on the bridge circuit. For more details about why this is done see Micro Measurements Tech Tip 612.</p> <p>Here is another illustration of how things could be wired up. This is easy to do on a breadboard, but can also easily be done free-hanging and wrapped in heat shrink to make an adapter cable.</p> <p></p> <p>It's also worth noting that you could swap the strain gauge and R3 positions in the bridge. In fact that is the way this circuit is usually depicted (including in tech tip linked above). However, there is one thing I don't like about having the strain gauge on the high side of the bridge. If the gauge lead wire becomes cut or damaged, the excitation voltage could be shorted to GND. With the gauge on the low side of the bridge, the R3 resistance would still be in series if the leads are shorted.</p> <p>Now we have a full bridge and we can get the raw voltage reading the same way as the full bridge example above. We will want our channel set to bipolar, with a gain of 128.</p> <pre><code>int ch = 0;  //Channel bridge sensor is on\nad7794.setBipolar(ch, true);\nad7794.setGain(ch, 128);\nad7794.setEnabled(ch, true);\n</code></pre> <p>And then we read the voltage.</p> <pre><code>float rawVolts = ad7794.read(ch);\n</code></pre> <p>The only difference is in the way that we scale the readings. Strain is measured as a ratio of elongation for a given gauge length (inch/inch, mm/mm) and is generally represented by an epsilon '\ud835\udf3a'. However, because a strain value of 1.0 would actually be an extremely large amount of elongation, strain is usually expressed as microstrain or \u00b5\ud835\udf3a**.</p> <p>To scale our voltage reading to microstrain, we need to know the gauge factor of the gauge. The gauge factor is the ratio of change in resistance to a change in length (strain). Each package of strain gauges should come with a gauge factor. It is generally right around 2.</p> <p>To convert our raw voltage to microstrain we can use the following function:</p> <pre><code>//Conversion for 1/4 bridge strain gauge\nfloat voltsToMicrostrain(float vIn, float vEx, float gFactor) {\n\n//First get volts per volt of excitation\n  float Vr = vIn / vEx;\n\n  //Calculate and return microstrain\n  return 1E6 * ((4 * Vr) / (gFactor * (1 +  (2 * Vr)))); \n}\n</code></pre> <p>Then all we have to do is just call the function for any channels we are reading strain on.</p> <pre><code>float strainVal = voltsToMicrostrain(rawVolts, 2.5, 2.00);\n</code></pre>"},{"location":"analog_sensors/#thermocouples","title":"Thermocouples","text":"<p>A thermocouple is a type of temperature sensor that produces a small temperature-dependent voltage across a junction of two different metals. The metal alloys used determine critical characteristics such as output voltage (sensitivity), temperature range, and corrosion resistance. There are many standard alloy combinations that are designated simply as thermocouple \"types\", and are denoted by a single letter designation. For example, one of the most popular general use thermocouples is the Type K, which uses chromel and alumel, and has a working range of \u2212200 \u00b0C to +1350 \u00b0C.</p> <p>Thermocouples are very easy to hook up to the AD7794 FeatherWing, at least electrically speaking. They are however much more complicated from a code/mathematical perspective.</p> <p>The first thing you need to do to read a thermocouple on the FeatherWing is solder some jumpers closed on the underside of the board. This connects a pair of 1M Ohm bias resistors to the S+ and S- inputs. There are 2 jumpers for each channel. Both jumpers must be soldered closed for each channel you plan to use with a thermocouple.</p> <p> Bottom side solder jumpers</p> <p>The reason for this is that thermocouples can output a negative voltage (with respect to ground) and the AD7794 can't actually read a truly negative voltage. The \"bipolar\" range of the AD7794 is actually centered around the mid point between 0V and VCC. There is also an added benefit to using the bias resistors. If the thermocouple wire is cut or disconnected, the resistors will pull S+ to EXV and S- to GND. This can make it easy to detect that there is a problem with the connection.</p> <p>Technically speaking, you can read thermocouples on channels 0, 1, and 2 of the AD7794 without the external bias resistors by enabling on-chip bias resistors that are available on those channels. In my experience though, they seem to be a little noisier and less stable.</p> <p>Once the two jumpers are closed, we simply need to wire the thermocouple to the S+ and S- terminals. Thermocouple wire color codes can be a little strange. In the US a Type K thermocouple will probably have a red negative lead, and a yellow positive lead as depicted in the image below. However, many countries have there own standards. I have ordered some from amazon and received the German standard which is red positive, and green negative. Fortunately, if you get it backwards it wont hurt anything, and it will be pretty obvious (the indicated temperature will go down when heat is applied)</p> <p> Thermocouple connection</p> <p>As mentioned above, hooking up a thermocouple is easy, but they are a bit more complicated to read mathematically speaking. I am not going to dig into the math in this post, but detailed information about the calculations can be found here, here, and here. Basically we need to approximate the NIST lookup tables for a given thermocouple type with a polynomial equation. But we also need to apply \"cold junction\" temperature compensation, which requires calculating an offset voltage by using a set of inverse coefficients.</p> <p>To get this done, at least for Type K thermocouples, we can use some nice little functions that I originally found in this repository</p> <pre><code>float Thermocouple_Ktype_VoltageToTempDegC(float voltage) {\n   // http://srdata.nist.gov/its90/type_k/kcoefficients_inverse.html\n   float coef_1[] = {0, 2.5173462e1, -1.1662878, -1.0833638, -8.9773540e-1};            // coefficients (in mV) for -200 to 0C, -5.891mv to 0mv\n   float coef_2[] = {0, 2.508355e1, 7.860106e-2, -2.503131e-1, 8.315270e-2};            // coefficients (in mV) for 0 to 500C, 0mv to 20.644mv\n   float coef_3[] = {-1.318058e2, 4.830222e1, -1.646031, 5.464731e-2, -9.650715e-4};    // whoa, that's hot...\n   int i = 5;  // number of coefficients in array\n   float temperature;\n\n   float mVoltage = voltage * 1e3;\n\n   if(voltage &lt; 0) {\n    temperature = power_series(i, mVoltage, coef_1);\n   }else if (voltage &gt; 20.644){\n    temperature = power_series(i, mVoltage, coef_3);\n   }else{\n    temperature = power_series(i, mVoltage, coef_2);\n   }\n\n   return(temperature);\n}\n\nfloat Thermocouple_Ktype_TempToVoltageDegC(float temperature) {\n  // https://srdata.nist.gov/its90/type_k/kcoefficients.html\n  float coef_1[] = {0, 0.3945013e-1, 0.2362237e-4, -0.3285891e-6, -0.4990483e-8};               // coefficients (in mV) for -270 to 0C, -5.891mv to 0mv\n  float coef_2[] = {-0.17600414e-1, 0.38921205e-1, 0.1855877e-4, -0.9945759e-7, 0.31840946e-9}; // coefficients (in mV) for 0 to 1372C, 0mv to ....\n  float a_coef[] = {0.1185976, -0.1183432e-3, 0.1269686e3};\n  int i = 5;  // number of coefficients in array\n\n  float mVoltage;\n  float a_power = a_coef[1] * pow((temperature - a_coef[2]), 2);\n  float a_results = a_coef[0] * exp(a_power);\n\n  if(temperature &lt; 0) {\n    mVoltage = power_series(i, temperature, coef_2) + a_results;\n  } else {\n    mVoltage = power_series(i, temperature, coef_1);\n  }\n\n  return(mVoltage / 1e3);\n}\n\nfloat power_series(int n, float input, float coef[])\n {\n      //delay(10);      \n      int i;\n      float sum=coef[0];\n      for(i=1;i&lt;=(n-1);i++)\n           sum=sum+(pow(input, (float)i)*coef[i]);\n      return(sum);\n }\n</code></pre> <p>If we paste these into our sketch, the rest becomes pretty straight forward.</p> <p>First lets set up our channel for reading a thermocouple. A Type K thermocouple has an approximate sensitivity of 41 \u00b5V/\u00b0C and a range of \u2212200 \u00b0C to +1350 \u00b0C, therefore we are looking at a voltage output of roughly -8 mV to +55 mV. To use the full range of a Type K thermocouple we will set the gain to 32. This gives us a range of \u00b178.125 mV. In setup() we need to do the following for each channel that we will be using to read a thermocouple.</p> <pre><code>int ch = 0;  //Channel thermocouple is on\nad7794.setBipolar(ch, true);\nad7794.setGain(ch, 32);  // \u00b178.125 mV\nad7794.setEnabled(ch, true);\n</code></pre> <p>Now we need to measure our cold junction temperature. For this example we will use the temperature sensor built in to the AD7794. For many applications this will work fine. If you need more accuracy, you can calibrate the onboard sensor against an external reference thermometer, or you could use an additional external digital temp sensor.</p> <pre><code>//Reading channel 6 returns the temperature\n//from the onboard sensor in degrees C  \nadcTemperature = adc.read(6);\n</code></pre> <p>Next we calculate the the voltage offset for the cold junction compensation.</p> <pre><code>//Calculate the reference voltage for the cold junction \nfloat referenceVoltage = Thermocouple_Ktype_TempToVoltageDegC(adcTemperature);\n</code></pre> <p>Then we read the voltage and convert to temperature.</p> <pre><code>float reading = Thermocouple_Ktype_VoltageToTempDegC(adc.read(i) + referenceVoltage);\n</code></pre> <p>If reading multiple thermocouples, we already have our cold junction reference voltage so all we have to do is repeat the last line for each channel we have a thermocouple on. For example, If all 6 channels are being used for thermocouples we can just do this.</p> <pre><code>for(int i=0; i &lt; 6; i++){\n    readings[i] = Thermocouple_Ktype_VoltageToTempDegC(adc.read(i) + referenceVoltage);\n}\n</code></pre>"},{"location":"analog_sensors/#potentiometers","title":"Potentiometers","text":"<p>Potentiometers are a variable resistor generally consisting of a resistive element and a \"wiper\" that moves along that resistive element. This creates a voltage divider that varies the voltage that is read on the wiper. They are extremely common and you have almost certainly used one before. There are some very high quality, precise potentiometers out there that can be excellent for some displacement sensing applications. They can be great for long term, low power applications as long as you turn off the excitation voltage, they consume no power at all. They are however not well suited for high cycle applications because the contact between the wiper and the resistive element can wear out.</p> <p>I have used string potentiometers, or \"string pots\" (also called \"draw-wire\" sensors) for many tests and structural monitoring projects over the years.</p> <p>Potentiometers are very easy to read with the AD7794 FeatherWing. All you need is a short bit of jumper wire to connect the GND terminal to the S- terminal.</p> <p> Potentiometer wiring</p> <p>The output voltage range will be 0.0 to 2.5 V, so we will need to set the appropriate AIN channel on the AD7794 to Unipolar mode and a gain of 1 to read it properly.</p> <pre><code>int ch = 0;  //Channel potentiometer sensor is on\nad7794.setBipolar(ch, false);\nad7794.setGain(ch, 1);\nad7794.setEnabled(ch, true);\n</code></pre> <p>After that, we just read the voltage.</p> <pre><code>float rawVolts = ad7794.read(ch);\n</code></pre> <p>If we are just reading a regular old potentiometer, the voltage might be all we are trying to measure, or we might calibrate it for some specific measurement. However If we are reading an off the shelf displacement sensor, it will probably have a scaling factor rated in UNIT/V/V (where UNIT is inches or millimeters). This is basically handled in the same way as the full bridge example above.</p> <pre><code>float voltsToUnits(float vIn, float vEx, float scaleFactor){   \n   return (vIn / vEx) * scaleFactor;\n }\n</code></pre> <p>Tags: bias resistor, completion resistor, full bridge, load cell, quarter bridge, strain gauge, thermocouple, wheatstone bridge</p>"},{"location":"jlogger-601/","title":"JLogger-601","text":""},{"location":"jlogger-601/#description","title":"Description","text":"<p>I really wanted a go-to device for remotely monitoring a variety of sensors. I often need to monitor and log data from precision analog sensors like strain gauges, load cells, potentiometers, and thermocouples; as well as digital sensors over I2C and serial. I also usually have to do this in some pretty remote places where power may not be available, or is unreliable.</p> <p>This board is designed for ultra low power, long term remote monitoring using LoRaWan (or raw packet radio) for long range communication. It utilizes the ubiquitous SAMD21G18 microcontroller because it's low power, well supported, and stable. Of course it is also Arduino compatible and can be used with the Arduino IDE by installing the board support package and required libraries.</p> <p>Note: This documentation is currently a work in progress but I wanted to get the basics posted. I will continue to plug in details and plan to do walkthroughs of a couple more examples.</p>"},{"location":"jlogger-601/#basic-specifications","title":"Basic Specifications","text":"<ul> <li>6 differential 24-bit analog inputs with programmable gain amplifier (1 to 128)</li> <li>Sockets for custom input modules on each precision analog input channel</li> <li>MOSFET controlled 3.3V output to shut down power to external digital sensors</li> <li>2.5V Excitation voltage can be enabled/disabled in code to save power with analog sensors</li> <li>14 \u03bcA sleep current</li> <li>4 high speed 12-bit analog inputs (3.3V)</li> <li>1 x 12-bit analog output (3.3V) (shared pin with AIN0)</li> <li>Expansion headers</li> <li>Onboard LiPo charger (with trace-jumper to disable charging to allow for non-LiPo batteries)</li> <li>Onboard EUI-64 MAC IC</li> <li>SAMD21 microcontroller (Arduino Zero/M0 compatible)</li> <li>Optional RFM95 LoRa radio module</li> <li>Micro SD card slot</li> <li>Real Time Clock with battery backup</li> <li>USB-C connector for programming and charging</li> </ul>"},{"location":"jlogger-601/#pinouts","title":"Pinouts","text":"<p>External connections include 6 precision analog input groups in addition to standard IO and communication terminals and the usual 2 mm JST battery connector.</p> <p></p> <p>There are also internal expansion headers for digital IO and a 10 pin SWD debug header along with sockets for analog input modules that can be used for additional signal conditioning like bridge completion, bias resistors, or filtering. A few of the expansion header pins are shared with the external connections. The I\u00b2C SDA and SCL lines are shared so that a \"shield\" type add on board can have access to the I\u00b2C bus. The A0/DAC line is also shared so that the DAC can be accessed internally if needed.</p> <p></p>"},{"location":"jlogger-601/#summary-of-internal-pin-connections","title":"Summary of Internal Pin Connections","text":"<p>Pins for the onboard hardware interfaces have #defines in the board support package. Below is a summary of the defined names, and their corresponding Arduino IDE pin number.</p> Peripheral Pin Defined in BSP Pin # RFM95 Chip Select PIN_RFM_CS 2 RFM95 Reset PIN_RFM_RST 27 RFM95 DIO0 PIN_RFM_DIO_0 7 RFM95 DIO1 PIN_RFM_DIO_1 38 AD7794 Chip Select PIN_AD7794_CS 6 AD7794 Data Ready PIN_AD7794_RDY 8 Excitation Enable PIN_EX_EN 26 Blue LED PIN_BLUE_LED 25 Bus Voltage Monitor PIN_BUS_V A5 Switched 3.3V Enable PIN_SW_3V_EN 5"},{"location":"jlogger-601/#arduino-ide-support","title":"Arduino IDE Support","text":"<p>In the Arduino IDE click File-&gt;Preferences-&gt;Settings</p> <p></p> <p></p> <p>Paste in the following URL to tell the boards manager where to find json file</p> <p>https://NHBSystems.github.io/nhb_arduino_boards/package_NHBSys_index.json</p> <p>Now you can go into the Arduino Boards Manager, find the JLogger support package, and install it.</p> <p></p> <p>Once installed, you may want to select the board and upload the blink example sketch to check that things are working.</p>"},{"location":"jlogger-601/#required-libraries","title":"Required Libraries","text":"<p>Additionally you will need to install some libraries to use the onboard hardware, some may depend on how you intend to use the JLogger. In the future I hope to include some of this functionality into an all in one library similar to what Adafruit did for their Circuit Playground boards. Everything except the RadioHead library is available in the Arduino library manager.</p>"},{"location":"jlogger-601/#required","title":"Required","text":"<ul> <li>RTCZero</li> <li>NHB_AD7794</li> <li>Adafruit_SPIFlash (will also install Adafruit fork of SDFat)</li> <li>extEEPROM</li> </ul>"},{"location":"jlogger-601/#you-will-also-want-one-or-more-of-the-following-for-radio-support-depending-on-your-need","title":"You will also want one or more of the following for radio support, depending on your need","text":"<ul> <li>RadioHead</li> <li>MCCI LMIC LoRaWan Library</li> <li>Beelan LoRaWAN</li> <li>Some other library?</li> </ul>"},{"location":"jlogger-601/#example-sketches","title":"Example Sketches","text":"<p>Additional hardware specific examples are provided for LMIC and Beelan LoRaWan libraries. I hope to add a nice example for RadioHead in the future, but I know the standard examples will work fine as long as you set the pin mappings. The JLogger_601_Test_All example shows the basics of using the onboard hardware and can be used to check that everything is working. It also can be configured to use the RadioHead library to check that an RFM95 (or RFM69) is present and working.</p> <p>The example sketches can be cloned or downloaded from this repository: https://github.com/NHBSystems/JLogger-601-Examples</p>"},{"location":"jlogger-601/#testing-the-hardware","title":"Testing the Hardware","text":"<p>The JLogger_601_Test_All example is nice way to see initialization and basic use of the JLogger's hardware.</p> <p>If you have installed the RadioHead library, you can uncomment the appropriate HAS_RFMxx_RADIO line near the top of the file. The example will simply try to initialize the radio and set the frequency to check that the radio is present and working. It does not do any actual communication.</p> <pre><code>//#define HAS_RFM95_RADIO       // You must have the Radiohead library installed.\n//#define HAS_RFM69_RADIO\n#define RFM_FREQUENCY  915.00   // If testing radio, set frequency for your region\n</code></pre> <p>If for some reason you would like to skip testing any of the other hardware, you can comment out any of the following lines and the test will be skipped.</p> <pre><code>#define HAS_24AA025E64_CHIP     // Included on all boards now\n#define TEST_FLASH  \n#define TEST_LEDS\n#define TEST_AD7794\n#define TEST_SW3V\n</code></pre> <p>The tests are all run in setup() and will do the following.</p> <ol> <li>The sketch will flash a fun pattern with all the LEDs (except the charge indicator of course).</li> <li>Test the MOSFET controlled 3.3V output (SW_3V) by switching it on for 2 seconds. You can use a voltmeter or connect an LED to verify that its working.</li> <li>If you have the RadioHead library installed and have enabled the radio test, the example will then try to initialize the radio and set the frequency.</li> <li>Test the 24AA025E64 EUI &amp; EEPROM chip. The sketch will read the EUI, format it, and print it out to serial. (You may want to write it down somewhere if setting up LoRaWan later)</li> <li>Test the SPI Flash storage. Uses the Adfruit_SPIFlash library to read the JEDEC ID and flash size from the device and print them out to serial.</li> <li>Test the AD7794 ADC. Uses the NHB_AD7794 library to initialize the AD7794 and read all 6 channels plus the onboard temperature sensor.</li> </ol>"},{"location":"jlogger-601/#beelan-lorawan-library","title":"BeeLan LoRaWan Library","text":"<p>The JLogger-601_LoraWan_Example-BeelanLib example should help you get started with LoRaWAN using the Beelan LoRaWAN library and OTAA activation. It's a nice little library for a simplified application that just needs to get data to the server and maybe receive some downlinks. It however does not handle MAC commands and is not fully compliant with the LoRaWAN specification. This doesn't matter to much for many applications, especially if you are running your own server. This example also shows how to put JLogger to sleep between readings, and processing downlink commands.</p> <p>The library can be installed from the Arduino library manager or cloned/downloaded from it's GitHub repository (linked above). As I write this, the example has been tested with version 1.5.1.</p> <p>Near the top of the sketch there is a #define for the default sleep interval (in Seconds) that you can change if you would like the logger to start up with a different interval. If using a third party LoRaWAN server (e.g. The Things Network) be sure to respect their fair use or traffic policies.</p> <pre><code>#define DEFAULT_INTERVAL    30     //Interval we start at\n</code></pre> <p>A few lines below that you will find the OTAA credentials. The devEUI will be provided by the onboard 24AA025E64 MAC chip, however you must change the appEUI and appKey values to those used for your application. I use a private Chirpstack server which does not use an appEUI. The Things Network on the other hand does use it and will generate the value for you. A detailed guide to setting up the server side is beyond the scope of this guide but you can find information on setting up a new device on The Things Network here, and setting up a device on Chirpstack here. I may do a more detailed post on setting these up in the future (especially Chirpstack) but for now I'm going to assume that you have access to a LoRaWAN server.</p> <pre><code>//// OTAA credentials /////////////////////////////\nchar devEui[16];  //WE will fill this with EUI from 24AA025E64 chip\n/**************** YOU NEED TO SET THESE! *********/\nconst char *appEui = \"0000000000000000\"; //Chirpstack doesn't need this, but need for TTN\nconst char *appKey = \"00000000000000000000000000000000\"; //&lt;- You need to change this\n</code></pre> <p>A little further down we set the pin mapping between the library and the JLogger-601. If you are adapting the example to use with other hardware you will have to change these.</p> <pre><code>//Pin mapping for JLogger 601\nconst sRFM_pins RFM_pins = {\n  .CS = PIN_RFM_CS,      //2,\n  .RST = PIN_RFM_RST,    //27,\n  .DIO0 = PIN_RFM_DIO_0, //7,\n  .DIO1 = PIN_RFM_DIO_1, //38,\n  .DIO2 = 255, //Not connected\n  .DIO5 = 255, //Not connected\n};\n</code></pre>"},{"location":"jlogger-601/#setup","title":"Setup","text":"<p>In setup() we start with the following line to enable proper float support for the sprintf() function.</p> <pre><code>asm(\".global _printf_float\"); // Enable sprintf float support\n</code></pre> <p>If SERIAL_DEBUG has been defined the sketch will just sit and wait for a serial connection at this point, and then set the analog read resolution to 12 bit. This is the SAMD21 analog, not the AD7794. In this example it is used for measuring bus/battery voltage.</p> <p>Now we initialize the 24AA025E64 MAC chip..</p> <pre><code>//Initialize the 24AA025E64 \n  uint8_t eepStatus = eep.begin(eep.twiClock400kHz);   //go fast!\n  if (eepStatus) {\n    #ifdef SERIAL_DEBUG\n      Serial.print(F(\"extEEPROM.begin() failed, status = \"));\n      Serial.println(eepStatus);\n    //while (1);\n    #endif\n  }\n</code></pre> <p>.. Then read the EUI64 and convert it to a C style string of HEX numbers. This is the format required by the Beelan library but it also makes it easier to print out nicely.</p> <pre><code>//Read the EUI\n  eep.read(EUI64_MAC_ADDR, eui, EUI64_MAC_LENGTH); \n\n  //...And convert it to a HEX string\n  char buf[3];\n  for(int i=0;i&lt;8;i++){\n    sprintf(buf, \"%02x\",eui[i]);   \n    devEui[i*2] = buf[0];\n    devEui[i*2 + 1] = buf[1];\n  }\n  devEui[16] = 0; //NULL Termination\n\n  #ifdef SERIAL_DEBUG\n    Serial.print(F(\"devEUI: \"));\n    Serial.println(devEui);\n  #endif\n</code></pre> <p>Next we initialize the RTC library and sync nextAlarmSec and nextAlarmMin to the rtc time. These variables are used to schedule the next wake up time for each sleep cycle. Note that the RTC is not set to the actual time in this example, we are just using it to keep track time intervals so the absolute time doesn't really matter.</p> <pre><code> //Initialize RTC\n  rtc.begin();\n\n  //Set  to actual time here if needed\n\n  nextAlarmSec = rtc.getSeconds();\n  nextAlarmMin = rtc.getMinutes();\n</code></pre> <p>Then initialize the AD7794 and configure the channels. In this example we set all 6 channels to bipolar mode and a gain of 128. This would be appropriate for most bridge type sensors.</p> <pre><code>  // Initialize the AD7794\n  // Setup for bridge type sensors (e.g. load cell or pressure gauge)\n  // Set update rate to 19.6, 90 dB noise rejection at 60 Hz\n  // Set bipolar mode\n  // Set set all channels to a gain of 128\n  adc.begin();\n  adc.setUpdateRate(16.6); //&lt; Slow, but 16.6Hz rate enables 50/60hz noise rejection\n  for(int i=0; i &lt; 6; i++){\n    adc.setBipolar(i,true);\n    //delay(2);\n    adc.setGain(i, 128);\n    //delay(2);\n    adc.setEnabled(i,true);\n    //delay(2);\n  }\n</code></pre> <p>Now initialize the radio. If this fails, the code just enters an infinite loop and blinks the built in red LED since there is no point in continuing on.</p> <pre><code>//Initialize radio and LoRaWAN\n  if(!lora.init()){\n    #ifdef SERIAL_DEBUG\n      Serial.println(\"RFM95 not detected\");\n    #endif\n    delay(1000);\n    while(1){\n      //Just freak out\n      digitalWrite(LED_BUILTIN,LOW);\n      delay(500);\n      digitalWrite(LED_BUILTIN,HIGH);\n      delay(1000);\n    }    \n  }\n</code></pre> <p>.. Setup the LoRaWAN parameters. We are a going to be Class A device and we set the modulation to Spread Factor 7, 125 KHz bandwidth. This should be fine for experimenting around the house (probably a lot further) and will hog less airtime. If you are going for longer ranges, you may wish to change this. Just keep in mind that a larger Spread Factor will increase time on air.</p> <pre><code>// Set LoRaWAN Class change CLASS_A or CLASS_C\n  lora.setDeviceClass(CLASS_A);\n\n  // Set Data Rate\n  lora.setDataRate(SF7BW125);\n\n  // set channel to random\n  lora.setChannel(MULTI);\n\n  // Put OTAA Key and DevAddress here\n  lora.setDevEUI(devEui);\n  lora.setAppEUI(appEui);\n  lora.setAppKey(appKey);\n</code></pre> <p>.. And try to join the network. The sketch will endlessly attempt to join every 5 seconds until successful. This is probably way to short an interval but this is just an example. Once joined execution moves on to our main loop.</p> <pre><code>//Join procedure\n  bool isJoined;\n  do {\n    #ifdef SERIAL_DEBUG\n      Serial.println(\"Joining...\");\n    #endif \n    isJoined = lora.join();\n\n    //wait for 5s to try again\n    delay(5000);\n  }while(!isJoined);\n\n  #ifdef SERIAL_DEBUG\n    Serial.println(\"Joined to network\");\n  #endif\n</code></pre>"},{"location":"jlogger-601/#main-loop","title":"Main Loop","text":"<p>The main program loop is pretty straightforward. Basically we read the analog inputs, pack up the data, send it out, and go to sleep. All sensor readings are stored in the float array readings[].</p> <p>First we turn on the 2.5V excitation voltage to power connected bridge sensors</p> <pre><code>digitalWrite(PIN_EX_EN,LOW); //Turn on excitation\n</code></pre> <p>Then read the bus voltage.</p> <pre><code>readings[0] = getBusVoltage();\n</code></pre> <p>The getBusVoltage() function a little more complicated than you might expect due to the high source impedance of the 1Meg resistors I used in the voltage divider. Many of the development boards out there use 100k or even 10k resistors in a voltage divider to measure battery voltage. The problem with this is that it is a terrible waste of power for long term battery powered applications. I used 1M resistors to reduce that power drain down to around 2 uA, however this causes significant errors in the ADC readings because the default ADC configuration can't handle such high source impedance. The workaround is to change the ADC configuration to a much slower conversion rate that can handle the high impedance, take the reading, and then change it back. Here is the function</p> <pre><code>float getBusVoltage(){\n\n  //Increase the sample period to increase allowable\n  //source impedance\n  REG_ADC_SAMPCTRL = ADC_SAMPCTRL_SAMPLEN(32);\n  while (ADC-&gt;STATUS.bit.SYNCBUSY == 1);\n\n  //Take the reading\n  float val = ((analogRead(PIN_BUS_V) * 3.3) / 4096) *2;\n\n  //Now put it back to reset value\n  REG_ADC_SAMPCTRL = ADC_SAMPCTRL_SAMPLEN(0);\n  while (ADC-&gt;STATUS.bit.SYNCBUSY == 1);\n\n  return val;\n}\n</code></pre> <p>Of course this isn't 100% necessary if you just want to know if you are running out of batteries soon. It should also be noted that bus voltage is measured after a Schottky diode when running on battery, so the voltage will read ~0.2V lower than the actual battery voltage</p> <p>Next we read the AD7794. We read the on-chip temperature sensor first. Calling read on channel 6 will return the temperature reading in Degrees C. Then we loop through channels 0-5 to get our 6 24bit analog readings and turn the excitation back off to save power.</p> <pre><code>  //Read AD7794 chip temperature\n  readings[1] = adc.read(6);\n\n  //Read 6 ADC channels\n  for(int i=0; i &lt; 6; i++){\n    readings[i+2] = adc.read(i);\n  }\n  digitalWrite(PIN_EX_EN,HIGH); //Turn off excitation\n</code></pre> <p>And now we can send the readings out. This example takes a \"Keep It Simple\" approach to sending out the data. I simply memcpy() the readings array into sendBuffer and then send it out. You have to be aware of endianness, but this is for a specific architecture, and you have to provide your own JavaScript decode function on the server side anyway.</p> <pre><code>//Pack it up...\nmemcpy(sendBuffer, readings, sizeof(readings)); \n\n//...and ship it out  \nlora.sendUplink(sendBuffer, sizeof(sendBuffer), 0,1);  //This function has changed to include the mport arg\n                                                       //in the 1.5+ Version of the library. \n\n//lora.sendUplink(sendBuffer, sizeof(sendBuffer), 0);  //Earlier library versions\n</code></pre> <p>The decode/encode functions to use with this example are provided in comments at the end of the code, and will be listed later in this post.</p> <p>Next we update the LoRaWAN state machine..</p> <pre><code>lora.update();\n</code></pre> <p>.. and check to see if we have a downlink message. If we did call parseDownlink() to handle it and then blink the blue LED to show that we received a downlink message.</p> <pre><code>// Get reply and parse ///////////////////// \n  recvStatus = lora.readData(recvBuffer);      \n\n  if(recvStatus) {\n    parseDownlink(recvBuffer);\n\n    //Blink LED to show we got a downlink\n    digitalWrite(PIN_BLUE_LED,LOW);\n    delay(500);\n    digitalWrite(PIN_BLUE_LED,HIGH);\n  }\n</code></pre> <p>The parseDownlink() function is provided as an example of how you can handle commands sent from your application. The first byte of the buffer sent be the server/application is the \"command byte\" and the rest is payload. The meaning of the payload will depend on the command. This allows for up to 255 commands. On the server/application side an encode function will take a JSON formatted command and convert it to a compatible byte array. There is just one command in this example, which sets the tx/sleep interval, but you could easily add more by following the pattern.</p> <pre><code>void parseDownlink(char * buf){\n\n  //Struct to represent simple message\n  struct dlMessage_t{\n    uint8_t   cmd;\n    uint8_t   payload[32]; //Need to look into actual appropriate max payload size\n  } message;\n\n  memset(message.payload,0,sizeof(message.payload));  \n  memcpy(&amp;message, buf, sizeof(buf));\n\n  //Debug info\n  #ifdef SERIAL_DEBUG\n    Serial.print(F(\"Message received [ \"));\n    Serial.print(F(\"cmd: \"));\n    Serial.print(message.cmd,HEX);\n    Serial.print(F(\" Payload: \"));\n    for(int i=0;i&lt;sizeof(message.payload);i++){\n      Serial.print(message.payload[i],HEX);\n      Serial.print(' ');\n    }\n    Serial.println(\" ]\");\n  #endif\n\n  // We only have one command for now, but more can be added\n  // easily with additional if() statements.\n\n  // Set the transmit interval\n  if(message.cmd == DLCMD_SET_RATE){\n\n    //We got it! \n    digitalWrite(PIN_BLUE_LED,LOW);\n    delay(1000);\n    digitalWrite(PIN_BLUE_LED,HIGH);\n\n    uint16_t arg1; \n    arg1 =  message.payload[1] | message.payload[0] &lt;&lt; 8 ;    \n\n    #ifdef SERIAL_DEBUG\n      Serial.print(\"arg1 = \");\n      Serial.println(arg1,BIN);\n    #endif\n\n    //TODO: Set sleep interval here \n    if((arg1 &gt;= MIN_INTERVAL) &amp;&amp; (arg1 &lt; MAX_INTERVAL)){\n      sleepInterval = arg1;\n      //Just re-sync these whenever we change the interval to avoid timing issues\n      nextAlarmSec = rtc.getSeconds();\n      nextAlarmMin = rtc.getMinutes();\n\n      #ifdef SERIAL_DEBUG\n        Serial.print(F(\"Set inteval to \"));\n        Serial.println(arg1);\n      #endif\n    }\n\n  }else{\n    //Unknown command\n    #ifdef SERIAL_DEBUG\n      Serial.println(F(\"Unknown command\"));\n    #endif\n\n  }\n\n}\n</code></pre> <p>Note: Normally you could do the same thing with the port field in the LoRaWAN packet instead of creating your own command byte, but the Beelan library doesn't support extracting ports from the downlink message (yet?)</p> <p>Once we have dealt with any downlinks we are ready to go back to sleep. First we calculate the minutes and seconds for when we want to wake up based on our interval. The example is written for intervals of less than 1Hr (3600 sec), but it could be extended to handle larger intervals</p> <pre><code> nextAlarmSec = (nextAlarmSec + (sleepInterval % 60)) % 60;\n nextAlarmMin = (nextAlarmMin + (sleepInterval / 60)) % 60;\n</code></pre> <p>Then we set up the RTC alarm and attach the interrupt so we will wake from sleep when the alarm goes off.</p> <pre><code> if(sleepInterval &lt;= 60){\n    rtc.setAlarmSeconds(nextAlarmSec);    \n    rtc.enableAlarm(rtc.MATCH_SS); \n  }else{\n    rtc.setAlarmSeconds(nextAlarmSec);  \n    rtc.setAlarmMinutes(nextAlarmMin);\n    rtc.enableAlarm(rtc.MATCH_MMSS);\n  }\n\n  rtc.attachInterrupt(rtcAlarm);\n</code></pre> <p>.. and now we turn off the lights and go to sleep. (If SERAIL_DEBUG is defined we just fake it)</p> <pre><code> digitalWrite(LED_BUILTIN,LOW); \n  #ifdef SERIAL_DEBUG\n    Serial.println(F(\"Going to (Fake) sleep now\"));\n    delay(sleepInterval * 1000);\n    Serial.println(F(\"Good morning!\"));\n  #else\n    RFM_Sleep(); // Beelan library doesn't put the radio to sleep so do it manually\n\n    //rtc.standbyMode(); // &lt;-- Doesn't handle SysTick properly \n\n    goToSleep(); // Safe sleep function. Could probably also use ArduinoLowPower library    \n  #endif  \n  digitalWrite(LED_BUILTIN,HIGH); //Waste of power, but this is just an example\n</code></pre> <p>The Beelan library doesn't put the RFM95 radio to sleep so we have to do it manually with the RFM_Sleep() function which looks like this.</p> <pre><code>void RFM_Sleep(){\n\n    //Borrowed from the RadioHead library\n    const uint8_t RH_RF95_MODE_SLEEP      = 0x00;\n    const uint8_t RH_RF95_REG_01_OP_MODE  = 0x01;\n    const uint8_t RH_SPI_WRITE_MASK       = 0x80;\n\n    //Set NSS pin Low to start communication\n    digitalWrite(PIN_RFM_CS,LOW);\n\n    //Send Addres with MSB 1 to make it a write command\n    SPI.transfer(RH_RF95_REG_01_OP_MODE | RH_SPI_WRITE_MASK);\n    //Send Data\n    SPI.transfer(RH_RF95_MODE_SLEEP);\n\n    //Set NSS pin High to end communication\n    digitalWrite(PIN_RFM_CS,HIGH);\n}\n</code></pre> <p>Also, there is bug with the RTCZero library on the SAMD21 that will eventually cause it to lock up and not recover from sleep mode. The issue and solution are documented here. Because of this I put the microcontroller to sleep manually with the goToSleep() function which properly handles the SysTick interrupt.</p> <pre><code>void goToSleep(){\n  bool restoreUSBDevice = false;\n\n //Try to handle attached USB gracefully\n  if (SERIAL_PORT_USBVIRTUAL) {\n    USBDevice.standby();\n  } else {\n    USBDevice.detach();\n    restoreUSBDevice = true;\n  }\n\n  //Disable SysTick interupt\n  SysTick-&gt;CTRL &amp;= ~SysTick_CTRL_TICKINT_Msk;\n\n  //Go to sleep\n  SCB-&gt;SCR |= SCB_SCR_SLEEPDEEP_Msk;\n  __DSB();\n  __WFI();\n  //Code starts here after waking\n\n  //Reenable systick interrupt\n  SysTick-&gt;CTRL |= SysTick_CTRL_TICKINT_Msk;\n\n  if (restoreUSBDevice) {\n    USBDevice.attach();\n  }  \n}\n</code></pre> <p>You could also use the ArduinoLowPower library as the SysTick fix was added into it's sleep method in May of 2019 and is now essentially the same as the code above.</p> <p>And that's it, the sketch will just keep repeating that cycle.</p>"},{"location":"jlogger-601/#javascript-encodedecode-functions","title":"JavaScript Encode/Decode Functions","text":"<p>Example Javascript Decode/Encode functions for Chirpstack. This will also work for TTN but you have to change the decode signature slightly to Decoder(bytes, port)</p> <p>The bytesToFloat() function comes from here. It is used to convert a group of 4 bytes into a float. It's pretty simplistic doesn't and do anything to handle weird stuff like NaNs, but it's fine for this example. (I have run it for months without any issues)</p> <pre><code>function bytesToFloat(bytes) {\n  // JavaScript bitwise operators yield a 32 bits integer, not a float.\n  // Assume LSB (least significant byte first).\n  var bits = bytes[3]&lt;&lt;24 | bytes[2]&lt;&lt;16 | bytes[1]&lt;&lt;8 | bytes[0];\n  var sign = (bits&gt;&gt;&gt;31 === 0) ? 1.0 : -1.0;\n  var e = bits&gt;&gt;&gt;23 &amp; 0xff;\n  var m = (e === 0) ? (bits &amp; 0x7fffff)&lt;&lt;1 : (bits &amp; 0x7fffff) | 0x800000;\n  var f = sign * m * Math.pow(2, e - 150);\n  return f;\n\n  // The \"bias\" value, which is documented to be 127 for 32 bits single-precision \n  // IEEE-754 floating point, has been replaced by 150 in m * Math.pow(2, e - 150). \n  // This is effectively m \u00d7 2-23 \u00d7 2e-127 a.k.a. (m / 223) \u00d7 2e-127, and is a nice \n  // optimization to get the 24th implicit leading bit in the \"mantissa\".\n}  \n</code></pre> <p>The Decode() function is specifically for this example and will decode raw bytes into a JSON object containing battery voltage, temperature, and all 6 AIN channels from the AD7794. If using Chirpstack the signature is Decode(fPort, bytes), if TTN the signature is Decoder(bytes, port).</p> <pre><code>//function Decoder(bytes, port) {   // For The Things Network\nfunction Decode(fPort, bytes){   //For Chirpstack\n  var payloadObj = {\"BattVoltage\":\"\",\n                    \"Temperature\":\"\",\n                    \"Ch_0\":\"\",\n                    \"Ch_1\":\"\",\n                    \"Ch_2\":\"\",\n                    \"Ch_3\":\"\",\n                    \"Ch_4\":\"\",\n                    \"Ch_5\":\"\"};\n\n  //var floats = new Float32Array(2);\n  var b = 0;\n  payloadObj.BattVoltage = bytesToFloat(bytes.slice(b, b+=4));\n  payloadObj.Temperature = bytesToFloat(bytes.slice(b, b+=4));\n  payloadObj.Ch_0 = bytesToFloat(bytes.slice(b, b+=4));\n  payloadObj.Ch_1 = bytesToFloat(bytes.slice(b, b+=4));\n  payloadObj.Ch_2 = bytesToFloat(bytes.slice(b, b+=4));\n  payloadObj.Ch_3 = bytesToFloat(bytes.slice(b, b+=4));\n  payloadObj.Ch_4 = bytesToFloat(bytes.slice(b, b+=4));\n  payloadObj.Ch_5 = bytesToFloat(bytes.slice(b, b+=4));\n\n  return payloadObj;\n}\n</code></pre> <p>Finally, the Encode() function will take a JSON formatted command/argument pair and convert it to the 1 byte command value, and a 2 byte (uint_16) argument. (The syntax will be covered further down)</p> <pre><code>function Encode(fPort, obj) {\n  var bytes = [];\n\n  bytes[0] = obj.command &amp; 0xFF;\n\n  bytes[1] = (obj.arg1 &gt;&gt; 8) &amp; 0xFF;\n  bytes[2] = obj.arg1 &amp; 0xFF;\n\n  return bytes; \n}\n</code></pre> <p>If using Chirpstack, the functions need to be pasted into the CODEC section in your device profile.</p> <p></p> <p>If using The Things Network you add the encode and decode functions under Payload Formats in your application.</p> <p></p> <p>In this example there is only one valid command which is to change the TX interval. The byte value for the command is defined as 1 and it takes one argument, the interval in seconds. To set the TX interval to 60 seconds, the syntax to send the command would look like this.</p> <pre><code>{\"command\": 1, \"arg1\": 60}\n</code></pre> <p>Here is what it looks like in the Chirpstack Application Server web interface (found at Applications-&gt;YourApp-&gt;Devices-&gt;YourDevice)</p> <p></p> <p>And this is The Things Network console</p> <p></p>"},{"location":"jlogger-601/#todo-lmic-lorawan-example","title":"TODO: LMIC LoRaWan Example","text":""},{"location":"blog/","title":"Recent Posts","text":""},{"location":"blog/2021/03/28/reading-analog-sensors/","title":"Reading Analog Sensors","text":"<p>This is a quick guide on how to connect various analog sensors to the 6 Channel, Full Bridge FeatherWing. I'll try to give a little background on some of the sensor types, but this is not intended to be a detailed explanation of the underlying principles. Hopefully this will be enough to get you going in your potential application.</p>"},{"location":"blog/2021/03/28/reading-analog-sensors/#wheatstone-bridge-sensors","title":"Wheatstone Bridge Sensors","text":"<p>A Wheatstone bridge is a classic analog circuit for measuring an unknown resistance or perhaps more importantly, very small changes in resistance. Sensors that utilize Wheatstone bridges are usually referred to simply as \"bridge\" or \"bridge output\" sensors. They are most commonly associated with strain gauge based sensors, though they can also be used for other resistive sensors like RTDs and thermistors. For right now I will just focus on strain gauge circuits.</p> <p> Basic Wheatstone bridge Circuit</p>"},{"location":"blog/2021/03/28/reading-analog-sensors/#full-bridge-sensors","title":"Full Bridge Sensors","text":"<p>-Standard (non-amplified) load cells, pressure gauges, etc.-</p> <p>The most common (and easiest to use) type of strain gauged bridge sensor is the full bridge. In this configuration, all 4 of the bridge resistance elements are contained in the sensor. The most common use of full bridge sensors are for load cells and pressure gauges. Generally in these sensors all bridge elements are active, meaning all four vary with external stimulus. However some special applications may have 2 or 3 passive bridge completion resistors and only 1 or 2 elements are active. Fortunately, for this type of sensor, it really doesn't matter how it's configured on the inside, they are all treated the same \u2013 as a full bridge sensor.</p> <p>The output signal of a full bridge sensor is a very small voltage that is fraction of the input, or excitation voltage. The expected output of a bridge sensor is usually stated as it's mV/V output (millivolts per volt of excitation), at the full scale of the sensor. For example, if you have a 100 lb. load cell, and it's stated output is 2.2 mV/V, it will read 2.2 mV for every volt of excitation, when 100 lbs. of force is applied to it. Common output values for bridge sensors range from 1 mV/V to 4 mV/V. These outputs are too small to read accurately with the built in ADCs on most microcontrollers, which is why we typically need something like the AD7794. It has a programable gain amplifier and 24 bits of resolution to accurately read such small voltages.</p> <p>Note: I have seen some cheap \"load cells\" out there that are actually only a quarter bridge or half bridge device. These need to be handled differently and will be discussed later.</p> <p>Wiring up a full bridge sensor to the FeatherWing is actually quite easy (it is the main thing it was designed for). The general configuration is 4 wires. Two wires for the excitation voltage (usually marked as EX+ and EX-) and two wires for the output signal (usually marked as S+ and S-). They can be wired directly into the 4 terminals of any of the six available sensor input channels as shown below. This is the same the same for a load cell, pressure gauge, or any other full bridge sensor. You can safely reverse the polarity of the output signal by swapping the S+ and S- leads.</p> <p> Bridge sensor connection to sensor input channels</p> <p>There is often a shield wire too. Technically, the shield should be connected to a conductive enclosure if you have one. However if you don't have a conductive enclosure around your project, you may find that tying it into the GND connection helps with noise. In some circumstances though, it can actually create more problems (like if the load cell body at the other end is in contact with a different ground potential) so don't always assume that it will be better.</p> <p>We will need set the AD7794 to Bipolar mode. We will also want to set gain to 128, though some higher output sensors, or an very unbalanced bridge (large zero offset) may need it set to 64 to see the full output range.</p> <pre><code>AD7794 adc(AD7794_CS, 4000000, 2.50);\n\nvoid setup() {\n   ...\n   adc.begin();\n   ...\n   int ch = 0;  //Channel bridge sensor is on\n   ad7794.setBipolar(ch, true);\n   ad7794.setGain(ch, 128);\n   ad7794.setEnabled(ch, true);\n   ...\n}\n</code></pre> <p>To read the sensor we first need to read the voltage</p> <pre><code>float rawVolts = ad7794.read(ch);\n</code></pre> <p>And then we need to scale it. We will convert rawVolts to mV/V by multiplying by 1000, and dividing by the excitation voltage. Then we will multiply by the scaling factor that we can get from the mV/V rating of the load cell (or better yet, obtained from a calibration). We can use a simple function like below to handle this.</p> <pre><code>float voltsToEngUnits(float vIn, float vEx, float scaleFactor){\n   float mVpV = (vIn * 1000) / vEx;\n   return mVpV * scaleFactor;\n }\n</code></pre> <p>As an example, I have a small 10 lb. load cell I like to use when trying things out at my desk. It has a nominal rated output of 2 mV/V. In this case my scaling factor would be 5.00 (10 lb. / 2 mV/V = 5.00 ) and If I am using the AD7794 FeatherWing, the provided excitation voltage will be 2.50 V. So I can get my scaled output like this.</p> <pre><code>const float vEx = 2.500;\nconst float factor = 5.000;\n\nfloat loadLbs = voltsToEngUnits(rawVolts, vEx, factor);\nSerial.println(loadLbs);\n</code></pre> <p>Of course you usually wont have such nice round numbers in a real application.</p> <p>If you wanted to be really precise, or use an externally supplied excitation voltage, you could measure the excitation voltage on another channel (using the internal reference voltage) and use the measured voltage in the calculation. This is also how you could implement a 6 wire bridge connection that adds remote sense connections to compensate for voltage drop of the excitation voltage over very long cable runs. These are special cases and are beyond the scope of this guide, at least for right now.</p>"},{"location":"blog/2021/03/28/reading-analog-sensors/#quarter-bridge-sensors","title":"Quarter Bridge Sensors","text":"<p>A quarter bridge (or 1/4 bridge) sensor consists of only a single resistive sensing element. The rest of the Wheatstone bridge circuit needs to be completed by bridge completion resistors. The most common 1/4 bridge sensor by far is a single strain gauge, so that is what we'll focus on here.</p> <p> A strain gauge installed on a steel beam</p> <p>Strain gauges come in 3 common resistances; 120 Ohm, 350 Ohm, and 1000 Ohm. I recommend the 1000 Ohm variety for 2 reasons. First, they draw less current. This is obviously good if your trying you're running off a battery, but also because strain gages can drift due to self heating. Less current means less self heating, and therefore less drift. The second reason is that 1000 Ohms is a common resistance. Bridge completion resistors need have extremely tight tolerances and (perhaps more importantly), they need to have extremely small temperature coeffects. It can be much easier to find an acceptable 1000 Ohm resistor than a 120 or 350. The latter can be hard to find, and you could end up paying quite a bit for a single resistor.</p> <p>Electrically speaking, the circuit is basically the same as the full bridge. In this case however, only one of the 4 resistances is a sensing element, and it is typically located at the end of some length of wire and bonded to the item you are testing. R1 through R3 are simply precision resistors.</p> <p> Quarter bridge circuit</p> <p>Another subtle difference is that the S+ connection should be connected at the strain gauge, not at the bridge completion resistor. This is to reduce the effects of the strain gauge lead wire resistance on the bridge circuit. For more details about why this is done see Micro Measurements Tech Tip 612.</p> <p>Here is another illustration of how things could be wired up. This is easy to do on a breadboard, but can also easily be done free-hanging and wrapped in heat shrink to make an adapter cable.</p> <p></p> <p>It's also worth noting that you could swap the strain gauge and R3 positions in the bridge. In fact that is the way this circuit is usually depicted (including in tech tip linked above). However, there is one thing I don't like about having the strain gauge on the high side of the bridge. If the gauge lead wire becomes cut or damaged, the excitation voltage could be shorted to GND. With the gauge on the low side of the bridge, the R3 resistance would still be in series if the leads are shorted.</p> <p>Now we have a full bridge and we can get the raw voltage reading the same way as the full bridge example above. We will want our channel set to bipolar, with a gain of 128.</p> <pre><code>int ch = 0;  //Channel bridge sensor is on\nad7794.setBipolar(ch, true);\nad7794.setGain(ch, 128);\nad7794.setEnabled(ch, true);\n</code></pre> <p>And then we read the voltage.</p> <pre><code>float rawVolts = ad7794.read(ch);\n</code></pre> <p>The only difference is in the way that we scale the readings. Strain is measured as a ratio of elongation for a given gauge length (inch/inch, mm/mm) and is generally represented by an epsilon '\ud835\udf3a'. However, because a strain value of 1.0 would actually be an extremely large amount of elongation, strain is usually expressed as microstrain or \u00b5\ud835\udf3a**.</p> <p>To scale our voltage reading to microstrain, we need to know the gauge factor of the gauge. The gauge factor is the ratio of change in resistance to a change in length (strain). Each package of strain gauges should come with a gauge factor. It is generally right around 2.</p> <p>To convert our raw voltage to microstrain we can use the following function:</p> <pre><code>//Conversion for 1/4 bridge strain gauge\nfloat voltsToMicrostrain(float vIn, float vEx, float gFactor) {\n\n//First get volts per volt of excitation\n  float Vr = vIn / vEx;\n\n  //Calculate and return microstrain\n  return 1E6 * ((4 * Vr) / (gFactor * (1 +  (2 * Vr)))); \n}\n</code></pre> <p>Then all we have to do is just call the function for any channels we are reading strain on.</p> <pre><code>float strainVal = voltsToMicrostrain(rawVolts, 2.5, 2.00);\n</code></pre>"},{"location":"blog/2021/03/28/reading-analog-sensors/#thermocouples","title":"Thermocouples","text":"<p>A thermocouple is a type of temperature sensor that produces a small temperature-dependent voltage across a junction of two different metals. The metal alloys used determine critical characteristics such as output voltage (sensitivity), temperature range, and corrosion resistance. There are many standard alloy combinations that are designated simply as thermocouple \"types\", and are denoted by a single letter designation. For example, one of the most popular general use thermocouples is the Type K, which uses chromel and alumel, and has a working range of \u2212200 \u00b0C to +1350 \u00b0C.</p> <p>Thermocouples are very easy to hook up to the AD7794 FeatherWing, at least electrically speaking. They are however much more complicated from a code/mathematical perspective.</p> <p>The first thing you need to do to read a thermocouple on the FeatherWing is solder some jumpers closed on the underside of the board. This connects a pair of 1M Ohm bias resistors to the S+ and S- inputs. There are 2 jumpers for each channel. Both jumpers must be soldered closed for each channel you plan to use with a thermocouple.</p> <p> Bottom side solder jumpers</p> <p>The reason for this is that thermocouples can output a negative voltage (with respect to ground) and the AD7794 can't actually read a truly negative voltage. The \"bipolar\" range of the AD7794 is actually centered around the mid point between 0V and VCC. There is also an added benefit to using the bias resistors. If the thermocouple wire is cut or disconnected, the resistors will pull S+ to EXV and S- to GND. This can make it easy to detect that there is a problem with the connection.</p> <p>Technically speaking, you can read thermocouples on channels 0, 1, and 2 of the AD7794 without the external bias resistors by enabling on-chip bias resistors that are available on those channels. In my experience though, they seem to be a little noisier and less stable.</p> <p>Once the two jumpers are closed, we simply need to wire the thermocouple to the S+ and S- terminals. Thermocouple wire color codes can be a little strange. In the US a Type K thermocouple will probably have a red negative lead, and a yellow positive lead as depicted in the image below. However, many countries have there own standards. I have ordered some from amazon and received the German standard which is red positive, and green negative. Fortunately, if you get it backwards it wont hurt anything, and it will be pretty obvious (the indicated temperature will go down when heat is applied)</p> <p> Thermocouple connection</p> <p>As mentioned above, hooking up a thermocouple is easy, but they are a bit more complicated to read mathematically speaking. I am not going to dig into the math in this post, but detailed information about the calculations can be found here, here, and here. Basically we need to approximate the NIST lookup tables for a given thermocouple type with a polynomial equation. But we also need to apply \"cold junction\" temperature compensation, which requires calculating an offset voltage by using a set of inverse coefficients.</p> <p>To get this done, at least for Type K thermocouples, we can use some nice little functions that I originally found in this repository</p> <pre><code>float Thermocouple_Ktype_VoltageToTempDegC(float voltage) {\n   // http://srdata.nist.gov/its90/type_k/kcoefficients_inverse.html\n   float coef_1[] = {0, 2.5173462e1, -1.1662878, -1.0833638, -8.9773540e-1};            // coefficients (in mV) for -200 to 0C, -5.891mv to 0mv\n   float coef_2[] = {0, 2.508355e1, 7.860106e-2, -2.503131e-1, 8.315270e-2};            // coefficients (in mV) for 0 to 500C, 0mv to 20.644mv\n   float coef_3[] = {-1.318058e2, 4.830222e1, -1.646031, 5.464731e-2, -9.650715e-4};    // whoa, that's hot...\n   int i = 5;  // number of coefficients in array\n   float temperature;\n\n   float mVoltage = voltage * 1e3;\n\n   if(voltage &lt; 0) {\n    temperature = power_series(i, mVoltage, coef_1);\n   }else if (voltage &gt; 20.644){\n    temperature = power_series(i, mVoltage, coef_3);\n   }else{\n    temperature = power_series(i, mVoltage, coef_2);\n   }\n\n   return(temperature);\n}\n\nfloat Thermocouple_Ktype_TempToVoltageDegC(float temperature) {\n  // https://srdata.nist.gov/its90/type_k/kcoefficients.html\n  float coef_1[] = {0, 0.3945013e-1, 0.2362237e-4, -0.3285891e-6, -0.4990483e-8};               // coefficients (in mV) for -270 to 0C, -5.891mv to 0mv\n  float coef_2[] = {-0.17600414e-1, 0.38921205e-1, 0.1855877e-4, -0.9945759e-7, 0.31840946e-9}; // coefficients (in mV) for 0 to 1372C, 0mv to ....\n  float a_coef[] = {0.1185976, -0.1183432e-3, 0.1269686e3};\n  int i = 5;  // number of coefficients in array\n\n  float mVoltage;\n  float a_power = a_coef[1] * pow((temperature - a_coef[2]), 2);\n  float a_results = a_coef[0] * exp(a_power);\n\n  if(temperature &lt; 0) {\n    mVoltage = power_series(i, temperature, coef_2) + a_results;\n  } else {\n    mVoltage = power_series(i, temperature, coef_1);\n  }\n\n  return(mVoltage / 1e3);\n}\n\nfloat power_series(int n, float input, float coef[])\n {\n      //delay(10);      \n      int i;\n      float sum=coef[0];\n      for(i=1;i&lt;=(n-1);i++)\n           sum=sum+(pow(input, (float)i)*coef[i]);\n      return(sum);\n }\n</code></pre> <p>If we paste these into our sketch, the rest becomes pretty straight forward.</p> <p>First lets set up our channel for reading a thermocouple. A Type K thermocouple has an approximate sensitivity of 41 \u00b5V/\u00b0C and a range of \u2212200 \u00b0C to +1350 \u00b0C, therefore we are looking at a voltage output of roughly -8 mV to +55 mV. To use the full range of a Type K thermocouple we will set the gain to 32. This gives us a range of \u00b178.125 mV. In setup() we need to do the following for each channel that we will be using to read a thermocouple.</p> <pre><code>int ch = 0;  //Channel thermocouple is on\nad7794.setBipolar(ch, true);\nad7794.setGain(ch, 32);  // \u00b178.125 mV\nad7794.setEnabled(ch, true);\n</code></pre> <p>Now we need to measure our cold junction temperature. For this example we will use the temperature sensor built in to the AD7794. For many applications this will work fine. If you need more accuracy, you can calibrate the onboard sensor against an external reference thermometer, or you could use an additional external digital temp sensor.</p> <pre><code>//Reading channel 6 returns the temperature\n//from the onboard sensor in degrees C  \nadcTemperature = adc.read(6);\n</code></pre> <p>Next we calculate the the voltage offset for the cold junction compensation.</p> <pre><code>//Calculate the reference voltage for the cold junction \nfloat referenceVoltage = Thermocouple_Ktype_TempToVoltageDegC(adcTemperature);\n</code></pre> <p>Then we read the voltage and convert to temperature.</p> <pre><code>float reading = Thermocouple_Ktype_VoltageToTempDegC(adc.read(i) + referenceVoltage);\n</code></pre> <p>If reading multiple thermocouples, we already have our cold junction reference voltage so all we have to do is repeat the last line for each channel we have a thermocouple on. For example, If all 6 channels are being used for thermocouples we can just do this.</p> <pre><code>for(int i=0; i &lt; 6; i++){\n    readings[i] = Thermocouple_Ktype_VoltageToTempDegC(adc.read(i) + referenceVoltage);\n}\n</code></pre>"},{"location":"blog/2021/03/28/reading-analog-sensors/#potentiometers","title":"Potentiometers","text":"<p>Potentiometers are a variable resistor generally consisting of a resistive element and a \"wiper\" that moves along that resistive element. This creates a voltage divider that varies the voltage that is read on the wiper. They are extremely common and you have almost certainly used one before. There are some very high quality, precise potentiometers out there that can be excellent for some displacement sensing applications. They can be great for long term, low power applications as long as you turn off the excitation voltage, they consume no power at all. They are however not well suited for high cycle applications because the contact between the wiper and the resistive element can wear out.</p> <p>I have used string potentiometers, or \"string pots\" (also called \"draw-wire\" sensors) for many tests and structural monitoring projects over the years.</p> <p>Potentiometers are very easy to read with the AD7794 FeatherWing. All you need is a short bit of jumper wire to connect the GND terminal to the S- terminal.</p> <p> Potentiometer wiring</p> <p>The output voltage range will be 0.0 to 2.5 V, so we will need to set the appropriate AIN channel on the AD7794 to Unipolar mode and a gain of 1 to read it properly.</p> <pre><code>int ch = 0;  //Channel potentiometer sensor is on\nad7794.setBipolar(ch, false);\nad7794.setGain(ch, 1);\nad7794.setEnabled(ch, true);\n</code></pre> <p>After that, we just read the voltage.</p> <pre><code>float rawVolts = ad7794.read(ch);\n</code></pre> <p>If we are just reading a regular old potentiometer, the voltage might be all we are trying to measure, or we might calibrate it for some specific measurement. However If we are reading an off the shelf displacement sensor, it will probably have a scaling factor rated in UNIT/V/V (where UNIT is inches or millimeters). This is basically handled in the same way as the full bridge example above.</p> <pre><code>float voltsToUnits(float vIn, float vEx, float scaleFactor){   \n   return (vIn / vEx) * scaleFactor;\n }\n</code></pre> <p>Tags: bias resistor, completion resistor, full bridge, load cell, quarter bridge, strain gauge, thermocouple, wheatstone bridge</p>"}]}